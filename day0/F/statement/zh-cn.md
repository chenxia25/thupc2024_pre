{{ self.title() }}

{{ s('description') }}

有 $n$ 个机器人围成一圈，编号按照逆时针顺序分别为 $0\sim n-1$。

每个机器人有两只手。编号为 $i$ 的机器人初始「左手」指向编号 $l_i$ 的机器人，「右手」指向编号 $r_i$ 的机器人。

有的机器人头上镶有一个「宝石」。一共有三种「宝石」。

所有的机器人内部都写有 $m$ 行「指令」，「指令」有以下这些形式：

### 指令

「指令」分为「基础指令」和「高级指令」两种。「高级指令」的功能会更复杂一些，但它们本质上没有多大区别。下面介绍这些「指令」的格式以及它们被「执行」时的效果。文中的“自己”一词均指拥有这条「指令」的机器人。

#### 基础指令

- `SLACKOFF`：**「摸鱼」**，即什么也不做。
- `MOVE h z`：将第 $h$ 只手向逆时针方向**「移动」**$z$ 个机器人的位置。当 $h=0$ 时表示「左手」，当 $h=1$ 时表示「右手」，下同。
- `FUSE h`：如果自己的头上有「宝石」，则创造一个自己头上的「宝石」的复制，然后将其与第 $h$ 只手指向的机器人头上的「宝石」**「聚合」**，并镶嵌回对方头上。两个相同类型的「宝石」在「聚合」时会一起消失，两个不同类型的「宝石」在「聚合」时会变成第三种类型的「宝石」。特殊地，如果原先对方头上没有「宝石」，则会直接把创造的「宝石」镶嵌到对方头上。
- `SWAP h x y`：将第 $h$ 只手指向的机器人的第 $x$ 行「指令」与自己的第 $y$ 行「指令」**「对调」**。
- `MIRROR h x`：将第 $h$ 只手指向的机器人的第 $x$ 行「指令」**「镜像」**取反，即将「指令」中的 $h$ 取反（$0$ 变成 $1$，$1$ 变成 $0$）。特殊地，它对 `SLACKOFF` 指令没有效果；而对 `DEATHRATTLE` 指令和 `TRIGGER` 指令，修改的是「触发」时「执行」的「指令」中的 $h$。
- `REPLACE h x <COMMAND>`：将第 $h$ 只手指向的机器人的第 $x$ 行「指令」**「替换」**为 `<COMMAND>`。其中 `<COMMAND>` 为一条完整的「指令」。这个「指令」可以是 `REPLACE`、`DEATHRATTLE`、`TRIGGER` **之外**的任意一种。

#### 高级指令 

- `ACTIVATE h`：如果自己头上有「宝石」，则**「激活」**第 $h$ 只手指向的机器人，即按顺序「执行」那个机器人的所有「指令」。当那个机器人的所有「指令」「执行」完毕后，或因为被「开除」而中止「执行」，该「指令」才算「执行」完毕。如果如果自己头上没有「宝石」，则什么也不做。

- `OCCUPY h`：创造一个「宝石」、双手指向、「指令」序列均与自己的第 $h$ 只手指向的机器人一致的机器人，然后**「开除」**另一只手指向的机器人，最后让这个新的机器人**「占据」**这个原来的位置。新机器人的编号和被「开除」的机器人编号相同。如果被「开除」的机器人有正在执行的「指令」或即将执行的「指令」，这些「指令」都不会算作「执行」完毕或被「执行」。即使双手指向了同一个机器人或者被「开除」的是自己也要进行这样的操作。

- `DEATHRATTLE <COMMAND>`：`DEATHRATTLE` 指令不会被「执行」，即按顺序「执行」时会跳过该「指令」。当自己即将被「开除」时，自己最靠前的 `DEATHRATTLE` 指令就会被**「触发」**，「执行」一次对应的 `<COMMAND>`。「执行」完这条 `<COMMAND>` 及因其「触发」或间接「触发」的所有「指令」之后自己才会被「开除」。其中 `<COMMAND>` 为一条完整的「基础指令」。

- `TRIGGER <COMMANDNAME>: <COMMAND>`：其中 `<COMMANDNAME>` 表示「指令」的名称，即一条「指令」中的第一个全大写单词；`<COMMAND>` 表示一条完整的「基础指令」。`TRIGGER` 指令不会被「执行」，即按顺序「执行」时会跳过该「指令」。但是，当一个**其他**机器人「执行」完一条「指令」之后，「右手」指向自己 ，且双方都没有被「开除」时，自己最靠前的满足如下条件之一的 `TRIGGER` 指令（如果有）就会被**「触发」**——「执行」一次对应的 `<COMMAND>`：

  - 刚刚「执行」完毕的「指令」为 `<COMMANDNAME>` 指令；
  - `<COMMANDNAME>` 为 `DEATHRATTLE` 或 `TRIGGER` 时，刚刚「执行」的「指令」是`<COMMANDNAME>` 指令被「触发」时「执行」的「指令」。

  「执行」完毕后会回到原来的「执行」顺序中。

你需要从 $0$ 号机器人开始按照编号顺序一圈又一圈地「激活」这些机器人，并输出「执行」的前 $k$ 条指令的有关信息。

{{ s('input format') }}

{{ self.input_file() }}

第一行三个正整数 $n,m,k$。

接下来按照编号从小到大的顺序表示 $n$ 个机器人的信息。

对于每个机器人，第一行三个非负整数 $l_i,r_i,g_i$ 表示「左手」指向的机器人编号，「右手」指向的机器人编号，头上镶嵌的「宝石」的种类。特殊地，$g_i=0$ 表示头上没有镶嵌「宝石」。

接下来 $m$ 行，按顺序表示机器人的「指令」，「指令」的格式见题目描述。

{{ s('output format') }}

{{ self.output_file() }}

输出 $k$ 行，按顺序描述前 $k$ 条开始「执行」的指令的相关信息，在开始「执行」前输出，每条一行，格式如下：

- 「摸鱼」时输出 `Robot <id> slacks off.`。其中 `<id>` 为一个整数，表示「执行」当前「指令」的机器人编号，下同。
- 「移动」时输出 `Robot <id> moves its <side> hand towards Robot <id2>.`。其中 `<side>` 为 `left` 或 `right`，表示移动了哪只手（`left` 表示「左手」，`right` 表示「右手」）；`<id2>` 为一个整数，表示移动之后这只手指向的机器人的编号。
- 「聚合」时输出 `Robot <id> embeds a Gem of type <typeid> onto Robot <id2>.`。其中 `<typeid>` 为一个整数，表示「聚合」之后「宝石」的种类。特殊地，用 $0$ 表示没有「宝石」的情况。`<id2>` 为被镶嵌「宝石」的机器人的编号。
- 「对调」时输出 `Robot <id> swaps a line of command with Robot <id2>.`。其中 `<id2>` 为一个整数，表示与之「对调」「指令」的机器人编号。
- 「替换」或「镜像」取反时输出 `Robot <id> replaces a line of command of Robot <id2>.`。其中 `<id2>` 为一个整数，表示被「替换」或「镜像」取反「指令」的机器人编号。
- 「执行」 `ACTIVATE` 指令且成功「激活」时输出 `Robot <id> activates Robot <id2>.`。其中  `<id2>` 为一个整数，表示被「激活」的机器人编号。
- 「执行」 `ACTIVATE` 指令且未能「激活」时输出 `Robot <id> fails to activate a robot.`。
- 「占据」时输出 `Robot <id> replaces Robot <id2> with a copy of Robot <id3>.`。其中 `<id2>` 为一个整数，表示被「开除」的机器人编号；`<id3>` 为一个整数，表示新机器人来源的编号。
- `DEATHRATTLE` 指令和 `TRIGGER` 指令由于不会被「执行」就不需要输出，但当它们被「触发」时，仍然需要按照上面的格式输出对应的「基础指令」被「执行」的信息。

{{ s('sample', 1) }}

{{ self.sample_text() }}

{{ self.title_sample_description() }}

$1$ 号机器人的 `TRIGGER` 指令不会被「触发」，因为 `OCCUPY` 指令「执行」完毕后，它已经被「开除」了。

新的 $1$ 号机器人的 `SLACKOFF` 指令不会被「执行」，因为它在「执行」完 `OCCUPY` 指令之前就被「开除」了。

{{ s('sample', 2) }}

{{ self.sample_file() }}

{{ self.title_sample_description() }}

无私的馈赠。有力的援助。

{{ s('subtasks') }}

保证所有的指令的格式均正确。

保证 $2\le n\le 100$，$1\le m \le 10$，$1\le k \le 3\times 10^5$。

保证 $0\le l_i,r_i<n$，$0\le g_i \le 3$。

保证 $0\le h \le 1$，$1\le x,y \le m$，$1\le z<n$。所有输入的数都是整数。